////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2016, Aleksey Nikolaevich Dokshin. All right reserved.
//  Contacts: dant.it@gmail.com, dokshin@list.ru.
//
////////////////////////////////////////////////////////////////////////////////////////////////////
unit dant_DataBuffer;

interface

uses
  SysUtils, dant_utils, dant_log;


const
  CHARSET_OEM866 = 1;
  CHARSET_WIN1251 = 2;
  CHARSET_UTF8 = 3;

type

  TExOutOfRange = class(TExError);

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // Реализация реплики буфера для удобной работы с RAW данными (прямых\обратных преобразований),
  // реализованного в Java.
  // - Буфер всега занимает весь массив, т.к. он у буфера всегда свой.
  // - Кодировка строк в буфере одна из: OEM866, WIN1251, UTF8 (!).
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  TDataBuffer = class
    private
      fbuffer: TByteArray;
      fcapacity: int;

      fareaOffset, fareaLength: int;
      fposition: int;

      // Маркер для пометки текущей позиции и возможности последующего вычисления разницы между отмеченной
      // и текущей позицией. Может использоваться для определения кол-ва считанных или записанных байт при
      // различных операциях, для этого используется связка команд: mark() + marked().
      fmark: int;

      fcharset: int;

    public
      constructor Create(size: int; charset: int = CHARSET_UTF8);
      destructor Destroy(); override;

      function buffer(): TByteArray;
      function bufferPtr(): PByte;
      function capacity(): int;

      function area(offs, len: int): TDataBuffer; overload;
      function reset(): TDataBuffer;
      function rewind(startshift: int = 0): TDataBuffer;
      function flip(): TDataBuffer;
      function flipBuffer(): TDataBuffer;
      function tail(): TDataBuffer;
      function tailBuffer(): TDataBuffer;
      function offset(): int; overload;
      function offset(offs: int): TDataBuffer; overload;
      function offsetPtr(): PByte;
      function length(): int; overload;
      function length(len: int): TDataBuffer; overload;
      function lengthMaximize(): TDataBuffer;
      function shiftArea(shift: int): TDataBuffer;
      function shiftOffset(shift: int): TDataBuffer;
      function shiftLength(shift: int): TDataBuffer;

      function remaining(): int;
      function hasRemaining(count: int = 1): Boolean;

      function mark(): TDataBuffer;
      function markedPos(): int;
      function marked(): int;

      function pos(): int; overload;
      function pos(newpos: int): TDataBuffer; overload;
      function posPtr(): PByte;
      function posToEnd(): TDataBuffer;
      function shift(value: int): TDataBuffer;
      function getPosAndPos(newpos: int): int;
      function getPosAndShift(value: int): int;

      ////////////////////////////////////////////////////////////////////////////////////////////////
      function encodeString(const str: string): string;
      function decodeString(const str: string): string;

      ////////////////////////////////////////////////////////////////////////////////////////////////
      function getVarAt(idx: int; var buf; offs, len: int): TDataBuffer;
      function getVar(var buf; offs, len: int): TDataBuffer;
      function getAt(idx: int): int;
      function get(): int;
      function getIntAt(idx: int): int;
      function getInt(): int;
      function getInt2At(idx: int): int;
      function getInt2(): int;
      function getInt3At(idx: int): int;
      function getInt3(): int;
      function getLongAt(idx: int): Int64;
      function getLong(): Int64;
      function getLong5At(idx: int): Int64;
      function getLong5(): Int64;
      function getLong6At(idx: int): Int64;
      function getLong6(): Int64;
      function getLong7At(idx: int): Int64;
      function getLong7(): Int64;
      function getLongFromStringAt(idx, len: int): Int64;
      function getLongFromString(len: int): Int64;
      function getIntFromStringAt(idx, len: int): Int64;
      function getIntFromString(len: int): Int64;
      function getArrayAt(idx, len: int; const buf: TByteArray; offs: int): TDataBuffer;
      function getArray(len: int; const buf: TByteArray; offs: int): TDataBuffer;

      function getRawStringAt(idx, len: int): string;
      function getRawString(len: int): string;

      function getStringAt(idx: int; len: int): string;
      function getString(len: int): string;
      function getZStringAt(idx: int; len: int): string;
      function getZString(len: int): string;
      function getNStringAt(idx: int): string;
      function getNString(): string;
      function getHexAt(idx: int; len: int): string;
      function getHex(len: int = -1): string;
      function getLongFromBCDAt(idx: int; len: int): int64;
      function getLongFromBCD(len: int): int64;
      function getIntFromBCDAt(idx: int; len: int): int;
      function getIntFromBCD(len: int): int;

      ////////////////////////////////////////////////////////////////////////////////////////////////
      function putVarAt(idx: int; const buf; offs, len: int): TDataBuffer;
      function putVar(const buf; offs, len: int): TDataBuffer;
      function putAt(idx, value: int): TDataBuffer;
      function put(value: int): TDataBuffer;
      function putIntAt(idx, value: int): TDataBuffer;
      function putInt(value: int): TDataBuffer;
      function putInt2At(idx, value: int): TDataBuffer;
      function putInt2(value: int): TDataBuffer;
      function putInt3At(idx, value: int): TDataBuffer;
      function putInt3(value: int): TDataBuffer;
      function putLongAt(idx: int; value: Int64): TDataBuffer;
      function putLong(value: Int64): TDataBuffer;
      function putLong5At(idx: int; value: Int64): TDataBuffer;
      function putLong5(value: Int64): TDataBuffer;
      function putLong6At(idx: int; value: Int64): TDataBuffer;
      function putLong6(value: Int64): TDataBuffer;
      function putLong7At(idx: int; value: Int64): TDataBuffer;
      function putLong7(value: Int64): TDataBuffer;
      function putLongAsStringAt(idx: int; value: Int64; len: int): TDataBuffer;
      function putLongAsString(value: Int64; len: int): TDataBuffer;
      function putArrayAt(idx: int; const buf: TByteArray; offs, len: int): TDataBuffer;
      function putArray(const buf: TByteArray; offs, len: int): TDataBuffer;
      function putAreaAt(idx: int; const buf: TDataBuffer): TDataBuffer;
      function putArea(const buf: TDataBuffer): TDataBuffer;
      function putsAt(idx: int; const values: array of Byte): TDataBuffer;
      function puts(const values: array of Byte): TDataBuffer;
      function fillAt(idx, len, value: int): TDataBuffer;
      function fill(len, value: int): TDataBuffer;

      function putRawStringAt(idx: int; const str: string; maxlen: int = -1): int;
      function putRawString(const str: string; maxlen: int = -1): TDataBuffer;

      function putStringAt(idx: int; const str: string; maxlen: int = -1): int;
      function putString(const str: string; maxlen: int = -1): TDataBuffer;
      function putZStringAt(idx: int; const str: string; len: int): int;
      function putZString(const str: string; len: int): TDataBuffer;
      function putNStringAt(idx: int; const str: string): int;
      function putNString(const str: string): TDataBuffer;
      function putHexAt(const hex: string; idx, len: int): TDataBuffer;
      function putHex(const hex: string; len: int = -1): TDataBuffer;
      function putLongAsBCDAt(idx: int; value: int64; len: int): TDataBuffer;
      function putLongAsBCD(value: int64; len: int): TDataBuffer;

    private
      function putNStringLengthAt(idx, len: int): int;
      procedure exIfOutOfArea(idx, len: int; const name: string);
  end;



implementation

uses
  dant_utf8;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Конструктор.
////////////////////////////////////////////////////////////////////////////////////////////////////
constructor TDataBuffer.Create(size: int; charset: int);
begin
  if (size < 0) then raise TExOutOfRange.Create(Format('TDataBuffer(%d): size < 0', [size]));
  if (not isIn(charset, [CHARSET_OEM866, CHARSET_WIN1251, CHARSET_UTF8])) then
    raise TExOutOfRange.Create(Format('TDataBuffer(%d): unsupported charset (%d)!', [size, charset]));
  fcharset := charset;
  SetLength(fbuffer, size);
  fcapacity := size;
  area(0, size);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Деструктор.
////////////////////////////////////////////////////////////////////////////////////////////////////
destructor TDataBuffer.Destroy();
begin
  SetLength(fbuffer, 0);
end;




////////////////////////////////////////////////////////////////////////////////////////////////////
// Буфер.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.buffer(): TByteArray;
begin
  Result := fbuffer;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Указатель на начало буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.bufferPtr(): PByte;
begin
  Result := @buffer[0];
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Длина буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.capacity(): int;
begin
  Result := fcapacity;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка рабочей области (окна). Тек.позиция устанавливается в начало окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.area(offs, len: int): TDataBuffer;
begin
  if (offs < 0) or (len < 0) or (offs+len > fcapacity) then
    raise TExOutOfRange.Create('area(%d,%d) [%d]', [offs, len, fcapacity]);
  fareaOffset := offs;
  fareaLength := len;
  Result := pos(0).mark();
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка рабочей области окна на весь буфер с установкой тек.позиция в начало окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.reset(): TDataBuffer;
begin
  Result := area(0, fcapacity);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Обновление текущего рабочего окна с установкой тек.позицией в начало текущего окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.rewind(startshift: int = 0): TDataBuffer;
begin
  Result := area(fareaOffset, fareaLength).shift(startshift);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка рабочего окна от начала окна и до тек.позиции (не включительно) с установкой
// тек.позиции в начало окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.flip(): TDataBuffer;
begin
  Result := area(fareaOffset, fposition);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка рабочего окна от начала буфера (!) и до тек.позиции (не включительно). Тек.позиция в
// начало.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.flipBuffer(): TDataBuffer;
begin
  Result := area(0, fareaOffset + fposition);
end;  


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка рабочего окна от тек.позиции и до конца окна с установкой тек.позиции в начало окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.tail(): TDataBuffer;
begin
  Result := area(fareaOffset + fposition, fareaLength - fposition);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка рабочего окна от тек.позиции и до конца буфера (!). Тек.позиция в начало.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.tailBuffer(): TDataBuffer;
begin
  Result := area(fareaOffset + fposition, fcapacity - (fareaOffset + fposition));
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Получение смещения начала рабочего окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.offset(): int;
begin
  Result := fareaOffset;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка смещения рабочего окна с сохранением позиции его конца - размер окна изменяется.
// Установка тек.позиции в начало окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.offset(offs: int): TDataBuffer;
begin
  Result := area(offs, fareaOffset + fareaLength - offs);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Указатель на начало рабочего окна буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.offsetPtr(): PByte;
begin
  Result := @buffer[fareaOffset];
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Получение длины рабочего окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.length(): int;
begin
  Result := fareaLength;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка длины рабочего окна с установкой тек.позиции в начало окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.length(len: int): TDataBuffer;
begin
  Result := area(fareaOffset, len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка длины рабочего окна от начала окна и до конца буфера (!).
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.lengthMaximize(): TDataBuffer;
begin
  Result := area(fareaOffset, fcapacity - fareaOffset);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Сдвиг рабочего окна на указанную величину. Рамер окна не изменяется.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.shiftArea(shift: int): TDataBuffer;
begin
  Result := area(fareaOffset + shift, fareaLength);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Сдвиг начала рабочего окна с сохранением позиции его конца. Размер окна изменяется на размер
// сдвига.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.shiftOffset(shift: int): TDataBuffer;
begin
  Result := area(fareaOffset + shift, fareaLength - shift);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Сдвиг размера рабочего окна. Начало окна не изменяется, размер окна изменяется на размер сдвига.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.shiftLength(shift: int): TDataBuffer;
begin
  Result := area(fareaOffset, fareaLength + shift);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Получение кол-ва байт от тек.позиции до конца окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.remaining(): int;
begin
  Result := fareaLength - fposition;
end;  

////////////////////////////////////////////////////////////////////////////////////////////////////
// Проверка наличия данных. Т.е. недостижения конца рабочего окна.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.hasRemaining(count: int = 1): Boolean;
begin
  Result := (fposition + count) <= fareaLength;
end;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Маркировка текущей позиции. Может использоваться для определения кол-ва считанных или записанных
// байт при различных операциях, для этого используется связка команд: mark() + marked().
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.mark(): TDataBuffer;
begin
  fmark := fposition;
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Получение маркированной позиции.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.markedPos(): int;
begin
  Result := fmark;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Получение разницы между маркированной позицией и текущей. Может использоваться для определения
// кол-ва считанных или записанных байт при различных операциях, для этого используется связка
// команд: mark() + marked().
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.marked(): int;
begin
  Result := fposition - fmark;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.pos(): int;
begin
  Result := fposition;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Установка текущей позиции в рабочем окне. Может быть = длине окна (обозначает конец).
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.pos(newpos: int): TDataBuffer;
begin
  if (newpos < 0) or (newpos > fareaLength) then
    raise TExOutOfRange.Create('pos(%d) [%d]', [newpos, fareaLength]);
  fposition := newpos;
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Указатель на текущую позицию буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.posPtr(): PByte;
begin
  Result := @buffer[fareaOffset + fposition];
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.posToEnd(): TDataBuffer;
begin
  Result := pos(fareaLength);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.shift(value: int): TDataBuffer;
begin
  Result := pos(fposition + value);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getPosAndPos(newpos: int): int;
begin
  Result := fposition;
  pos(newpos);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getPosAndShift(value: int): int;
begin
  Result := fposition;
  shift(value);
end;






////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ПОЛУЧЕНИЕ ДАННЫХ ИЗ БУФЕРА
//
////////////////////////////////////////////////////////////////////////////////////////////////////

procedure TDataBuffer.exIfOutOfArea(idx, len: int; const name: string);
begin
  if (idx < 0) or (len < 0) or (idx+len > fareaLength) then
    raise TExOutOfRange.Create(Format('%s(%d,%d) [%d]', [name, idx, len, fareaLength]));
end;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Помещает в переменную (учитывая смещение и длину) кусок из буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getVarAt(idx: int; var buf; offs, len: int): TDataBuffer;
begin
  exIfOutOfArea(idx, len, 'getVarAt');
  Move(fbuffer[fareaOffset + idx], PChar(@buf)[offs], len);
  Result := self;
end;

////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getVar(var buf; offs, len: int): TDataBuffer;
begin
  Result := getVarAt(fposition, buf, offs, len).shift(len);
end;

////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getAt(idx: int): int;
begin
  exIfOutOfArea(idx, 1, 'getAt');
  Result := 0; getVarAt(idx, Result, 0, 1);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.get(): int;
begin
  Result := getAt(fposition);
  shift(1);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getIntAt(idx: int): int;
begin
  exIfOutOfArea(idx, 4, 'getIntAt');
  Result := 0; getVarAt(idx, Result, 0, 4);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getInt(): int;
begin
  Result := getIntAt(fposition);
  shift(4);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getInt2At(idx: int): int;
begin
  exIfOutOfArea(idx, 2, 'getInt2At');
  Result := 0; getVarAt(idx, Result, 0, 2);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getInt2(): int;
begin
  Result := getInt2At(fposition);
  shift(2);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getInt3At(idx: int): int;
begin
  exIfOutOfArea(idx, 3, 'getInt3At');
  Result := 0; getVarAt(idx, Result, 0, 3);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getInt3(): int;
begin
  Result := getInt3At(fposition);
  shift(3);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLongAt(idx: int): Int64;
begin
  exIfOutOfArea(idx, 8, 'getLongAt');
  Result := 0; getVarAt(idx, Result, 0, 8);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLong(): Int64;
begin
  Result := getLongAt(fposition);
  shift(8);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLong5At(idx: int): Int64;
begin
  exIfOutOfArea(idx, 5, 'getLong5At');
  Result := 0; getVarAt(idx, Result, 0, 5);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLong5(): Int64;
begin
  Result := getLong5At(fposition);
  shift(5);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLong6At(idx: int): Int64;
begin
  exIfOutOfArea(idx, 6, 'getLong6At');
  Result := 0; getVarAt(idx, Result, 0, 6);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLong6(): Int64;
begin
  Result := getLong6At(fposition);
  shift(6);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLong7At(idx: int): Int64;
begin
  exIfOutOfArea(idx, 7, 'getLong7At');
  Result := 0; getVarAt(idx, Result, 0, 7);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLong7(): Int64;
begin
  Result := getLong7At(fposition);
  shift(7);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Считывание числа записанного в буфер в текстовом виде (старшие регистры в начале).
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLongFromStringAt(idx, len: int): Int64;
var i: int;
begin
  exIfOutOfArea(idx, len, 'getLongFromStringAt');
  Result := 0;
  for i := 0 to len - 1 do
  begin
    Result := (Result * 10) + ((fbuffer[fareaOffset + idx + i] and $FF) - $30);
  end;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getLongFromString(len: int): Int64;
begin
  Result := getLongFromStringAt(fposition, len);
  shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getIntFromStringAt(idx, len: int): Int64;
begin
  Result := int(getLongFromStringAt(idx, len) and $FFFFFFFF);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getIntFromString(len: int): Int64;
begin
  Result := getIntFromStringAt(fposition, len);
  shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Копирование куска буфера в другой буфер с заданного смещения.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getArrayAt(idx, len: int; const buf: TByteArray; offs: int): TDataBuffer;
var dstsz: int;
begin
  dstsz := System.Length(buf);
  if ((offs < 0) or (len < 0) or (offs + len > dstsz)) then
    raise TExOutOfRange.Create('getArrayAt(%d,%d) dst:[%d]', [offs, len, dstsz]);
  // Если не делать условие - при нулевой длине буфера будет Range Check Error.
  if (len > 0) then getVarAt(idx, buf[low(buf)], offs, len);
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Копирование куска буфера в другой буфер с заданного смещения.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getArray(len: int; const buf: TByteArray; offs: int): TDataBuffer;
begin
  Result := getArrayAt(fposition, len, buf, offs).shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getRawStringAt(idx, len: int): string;
begin
  exIfOutOfArea(idx, len, 'getRawStringAt');
  SetLength(Result, len);
  // Если не делать условие - при нулевой длине строки будет Range Check Error.
  if (len > 0) then getVarAt(idx, Result[1], 0, len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getRawString(len: int): string;
begin
  Result := getRawStringAt(fposition, len);
  shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getStringAt(idx: int; len: int): string;
begin
  Result := decodeString(getRawStringAt(idx, len));
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getString(len: int): string;
begin
  Result := getStringAt(fposition, len);
  shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getZStringAt(idx: int; len: int): string;
var i, off: int;
begin
  exIfOutOfArea(idx, len, 'getZStringAt');
  // Первый нулевой символ - конец строки - обрезаем по нему.
  off := fareaOffset + idx;
  for i := 0 to len - 1 do
  begin
    if (fbuffer[off + i] = 0) then
    begin
      len := i;
      Break;
    end;
  end;
  Result := getStringAt(idx, len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getZString(len: int): string;
begin
  Result := getZStringAt(fposition, len);
  shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Получение строки с записанной длиной байт-массива строки (длина занимает от одного до четырех
// байт) из буфера, начиная с указанной позиции в рабочем окне.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getNStringAt(idx: int): string;
var i, v, len: int;
begin
  i := 0; len := 0;
  repeat
    v := getAt(idx + i);
    len := ((v and $7F) shl (7*i)) or len;
    i := i + 1;
  until ((i >= 4) or (v <= $7F)); // До тех пор пока False!
  Result := getStringAt(idx + i, len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Получение строки с записанной длиной байт-массива строки (длина занимает от одного до четырех
// байт) из буфера, начиная с тек.позиции в рабочем окне.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getNString(): string;
var i, v, len: int;
begin
  i := 0; len := 0;
  repeat
    v := get();
    len := ((v and $7F) shl (7*i)) or len;
    i := i + 1;
  until ((i >= 4) or (v <= $7F)); // До тех пор пока False!
  Result := getString(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Выдаёт HEX строку массива байт буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getHexAt(idx: int; len: int): string;
var s: string;
begin
  exIfOutOfArea(idx, len, 'getHexAt');
  SetLength(s, len);
  if (len > 0) then
  begin
    getVarAt(idx, s[1], 0, len);
    Result := StrToHexStr(s);
  end;  
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.getHex(len: int = -1): string;
begin
  if (len = -1) then len := remaining();
  Result := getHexAt(fposition, len);
  shift(len);
end;

// BCD значение - это число 1234 записывается как: 0x12, 0x34.
function TDataBuffer.getLongFromBCDAt(idx: int; len: int): int64;
var i, n: int;
begin
  Result := 0;
  for i := 0 to len-1 do
  begin
    n := getAt(idx + i);
    Result := (Result * 100) + ((n shr 4) * 10) + (n and $F);
  end;
end;

function TDataBuffer.getLongFromBCD(len: int): int64;
begin
  Result := getLongFromBCDAt(fposition, len);
  shift(len);
end;

function TDataBuffer.getIntFromBCDAt(idx: int; len: int): int;
begin
  Result := int(getLongFromBCDAt(idx, len));
end;

function TDataBuffer.getIntFromBCD(len: int): int;
begin
  Result := int(getLongFromBCD(len));
end;



////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ПОМЕЩЕНИЕ ДАННЫХ В БУФЕР
//
////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
// Помещает в буфер кусок памяти переменной (учитывая смещение и длину).
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putVarAt(idx: int; const buf; offs, len: int): TDataBuffer;
begin
  exIfOutOfArea(idx, len, 'putVarAt');
  Move(PChar(@buf)[offs], fbuffer[fareaOffset + idx], len);
  Result := self;
end;

////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putVar(const buf; offs, len: int): TDataBuffer;
begin
  Result := putVarAt(fposition, buf, offs, len).shift(len);
end;

////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putAt(idx, value: int): TDataBuffer;
begin
  exIfOutOfArea(idx, 1, 'putAt');
  Result := putVarAt(idx, value, 0, 1);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.put(value: int): TDataBuffer;
begin
  Result := putAt(fposition, value).shift(1);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putIntAt(idx, value: int): TDataBuffer;
begin
  exIfOutOfArea(idx, 4, 'putIntAt');
  Result := putVarAt(idx, value, 0, 4);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putInt(value: int): TDataBuffer;
begin
  Result := putIntAt(fposition, value).shift(4);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putInt2At(idx, value: int): TDataBuffer;
begin
  exIfOutOfArea(idx, 1, 'putInt2At');
  Result := putVarAt(idx, value, 0, 2);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putInt2(value: int): TDataBuffer;
begin
  Result := putInt2At(fposition, value).shift(2);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putInt3At(idx, value: int): TDataBuffer;
begin
  exIfOutOfArea(idx, 3, 'putInt3At');
  Result := putVarAt(idx, value, 0, 3);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putInt3(value: int): TDataBuffer;
begin
  Result := putInt3At(fposition, value).shift(3);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLongAt(idx: int; value: Int64): TDataBuffer;
begin
  exIfOutOfArea(idx, 8, 'putLongAt');
  Result := putVarAt(idx, value, 0, 8);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLong(value: Int64): TDataBuffer;
begin
  Result := putLongAt(fposition, value).shift(8);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLong5At(idx: int; value: Int64): TDataBuffer;
begin
  exIfOutOfArea(idx, 5, 'putLong5At');
  Result := putVarAt(idx, value, 0, 5);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLong5(value: Int64): TDataBuffer;
begin
  Result := putLong5At(fposition, value).shift(5);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLong6At(idx: int; value: Int64): TDataBuffer;
begin
  exIfOutOfArea(idx, 6, 'putLong6At');
  Result := putVarAt(idx, value, 0, 6);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLong6(value: Int64): TDataBuffer;
begin
  Result := putLong6At(fposition, value).shift(6);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLong7At(idx: int; value: Int64): TDataBuffer;
begin
  exIfOutOfArea(idx, 7, 'putLong7At');
  Result := putVarAt(idx, value, 0, 7);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLong7(value: Int64): TDataBuffer;
begin
  Result := putLong7At(fposition, value).shift(7);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLongAsStringAt(idx: int; value: Int64; len: int): TDataBuffer;
var i: int;
begin
  exIfOutOfArea(idx, len, 'putLongAsStringAt');
  for i := len-1 downto 0 do
  begin
    fbuffer[fareaOffset + idx + i] := Byte((value mod 10) + $30);
    value := value div 10;
  end;
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putLongAsString(value: Int64; len: int): TDataBuffer;
begin
  Result := putLongAsStringAt(fposition, value, len).shift(len);
end;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Помещает в буфер массив байт. Внимание! Не обрезает длину - должна быть корректна как для
// источника, так и для приемника!
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putArrayAt(idx: int; const buf: TByteArray; offs, len: int): TDataBuffer;
var srcsz: int;
begin
  srcsz := System.Length(buf);
  if ((offs < 0) or (len < 0) or (offs + len > srcsz)) then
    raise TExOutOfRange.Create('putArray(%d,%d) src:[%d]', [offs, len, srcsz]);
  if (len > 0) then putVarAt(idx, buf[low(buf)], offs, len);
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putArray(const buf: TByteArray; offs, len: int): TDataBuffer;
begin
  Result := putArrayAt(fposition, buf, offs, len).shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Запись в буфер с указанной позиции массива рабочего окна указанного буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putAreaAt(idx: int; const buf: TDataBuffer): TDataBuffer;
begin
  Result := putArrayAt(idx, buf.buffer(), buf.offset(), buf.length());
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Запись в буфер с тек.позиции массива рабочего окна указанного буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putArea(const buf: TDataBuffer): TDataBuffer;
begin
  Result := putArray(buf.buffer(), buf.offset(), buf.length());
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putsAt(idx: int; const values: array of Byte): TDataBuffer;
var len: int;
begin
  len := System.Length(values);
  exIfOutOfArea(idx, len, 'putsAt');
  if (len > 0) then putVarAt(idx, values[low(values)], 0, len);
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.puts(const values: array of Byte): TDataBuffer;
begin
  Result := putsAt(fposition, values).shift(System.Length(values));
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.fillAt(idx, len, value: int): TDataBuffer;
begin
  exIfOutOfArea(idx, len, 'fillAt');
  FillChar(fbuffer[fareaOffset + idx], len, value);
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.fill(len, value: int): TDataBuffer;
begin
  Result := fillAt(fposition, len, value).shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Кодирование строки из виндовой кодировки в кодировку буфера.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.encodeString(const str: string): string;
begin
  case fcharset of
    CHARSET_OEM866:  Result := dant_AnsiToOem(str);
    CHARSET_WIN1251: Result := str;
    CHARSET_UTF8:    Result := dant_AnsiToUTF8(str);
  end;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Кодирование строки кодировки буфера в виндовую кодировку. 
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.decodeString(const str: string): string;
begin
  case fcharset of
    CHARSET_OEM866:  Result := dant_OemToAnsi(str);
    CHARSET_WIN1251: Result := str;
    CHARSET_UTF8:    Result := dant_UTF8ToAnsi(str);
  end;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Запись строки в буфер без каких либо преобразований кодировок.
// Не более len байт (ограничитель), если = -1, то строка полностью, без ограничений.
// Возвращает реальное кол-во записанных байт.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putRawStringAt(idx: int; const str: string; maxlen: int = -1): int;
var n: int;
begin
  Result := 0;
  n := System.Length(str);
  if ((maxlen <> -1) and (n > maxlen)) then n := maxlen;
  exIfOutOfArea(idx, n, 'putRawStringAt');
  if (n > 0) then
  begin
    putVarAt(idx, str[1], 0, n);
    Result := n;
  end;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putRawString(const str: string; maxlen: int = -1): TDataBuffer;
var i: int;
begin
  i := putRawStringAt(fposition, str, maxlen);
  Result := shift(i);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Запись строки в буфер с приведением в кодировку буфера!
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putStringAt(idx: int; const str: string; maxlen: int = -1): int;
begin
  Result := putRawStringAt(idx, encodeString(str), maxlen);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putString(const str: string; maxlen: int = -1): TDataBuffer;
var i: int;
begin
  i := putStringAt(fposition, str, maxlen);
  Result := shift(i);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putZStringAt(idx: int; const str: string; len: int): int;
begin
  exIfOutOfArea(idx, len, 'putZStringAt');
  fillAt(idx, len, 0);
  Result := putStringAt(idx, str, len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putZString(const str: string; len: int): TDataBuffer;
begin
  putZStringAt(fposition, str, len);
  Result := shift(len);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Запись в буфер длины строки (в байтах) в специальном виде (от 1 до 4 байт).
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putNStringLengthAt(idx, len: int): int;
var v: int;
begin
  Result := 0;
  repeat
    v := len and $7F;
    len := len shr 7;
    if (len <> 0) then v := v or $80;
    putAt(idx + Result, v);
    Result := Result + 1;
  until ((Result >=4) or (len = 0));
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Запись в буфер строки предваряемая длиной байт-массива строки в специальном формате. С указанной
// позиции.
//
// Кол-во байт затраченных для записи длины байт-массива зависит от значения длины. Каждый байт
// содержит 7 бит данных и один бит указывающий на то, что далее следует еще один байт длины. Т.е.
// длина < (1<<7) - занимает 1 байт, длина менее (1<<14) - два байта, причем у первого байта 7бит=1,
// и т.д.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putNStringAt(idx: int; const str: string): int;
var n, sz: int;
    s: string;
begin
  s := encodeString(str);
  n := System.Length(s);
  sz := putNStringLengthAt(idx, n);
  putRawStringAt(idx + sz, s, n);
  Result := sz + n;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putNString(const str: string): TDataBuffer;
var n: int;
begin
  n := putNStringAt(fposition, str);
  Result := shift(n);
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
// Записывает в буфер массив, заданный HEX строкой. Если в строке данных не хватает, то добивается
// нулями.
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putHexAt(const hex: string; idx, len: int): TDataBuffer;
var s: string;
  n: int;
begin
  exIfOutOfArea(idx, len, 'putHexAt');
  s := HexStrToStr(hex);
  n := System.Length(s);
  if (n > len) then n := len;
  if (n > 0) then putVarAt(idx, s[1], 0, n);
  if (n < len) then fillAt(idx + n, len-n, 0);
  Result := self;
end;


////////////////////////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////////////////////////
function TDataBuffer.putHex(const hex: string; len: int = -1): TDataBuffer;
begin
  if (len = -1) then len := System.Length(hex) div 2;
  Result := putHexAt(hex, fposition, len).shift(len);
end;


// BCD значение - это число 1234 записывается как: 0x12, 0x34.
function TDataBuffer.putLongAsBCDAt(idx: int; value: int64; len: int): TDataBuffer;
var i, n1, n2: int;
begin
  for i := 1 to len do
  begin
    n1 := value mod 10;
    value := value div 10;
    n2 := (value mod 10) shl 4;
    value := value div 10;
    putAt(idx + len - i, n2 + n1);
  end;
  Result := self;
end;

function TDataBuffer.putLongAsBCD(value: int64; len: int): TDataBuffer;
begin
  Result := putLongAsBCDAt(fposition, value, len).shift(len);
end;

end.
